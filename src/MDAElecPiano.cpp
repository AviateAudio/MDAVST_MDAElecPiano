/*
 * Company: MDA VST
 * Effect Name: MDA Electric Piano
 * Description: A port of the famous MDA ePiano VST
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include "Aviate/EfxPrint.h"
#include "MDAElecPiano.h"

#include "mdaEPiano.h"

using namespace Aviate;

namespace MDAVST_MDAElecPiano {

MDAElecPiano::MDAElecPiano()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    // perform any necessary class initialization here
    m_piano = new mdaEPiano(16);
    m_piano->setProgram(0);
}

MDAElecPiano::~MDAElecPiano()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
    if (m_piano) delete m_piano;
}

void MDAElecPiano::m_init()
{
    m_isInit = true;
}

void MDAElecPiano::update(void)
{
    AudioBlock *inputAudioBlock = audioBlockReceiveReadOnly(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { return; } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    AudioBlock* leftOut = audioBlockAllocate();
    if (!leftOut) { release (inputAudioBlock); return; }
    AudioBlock* rightOut = audioBlockAllocate();
    if (!rightOut) { release(inputAudioBlock); release(leftOut); return; }


    m_piano->process(leftOut->data, rightOut->data);

    // // DO AUDIO EFFECT PROCESSING
    // for (unsigned idx=0; idx<AUDIO_SAMPLES_PER_BLOCK; idx++) {
    //     leftOut->data[idx]
    // }

    m_updateOutputPeak(leftOut); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(leftOut, 0);
    transmit(rightOut, 1);
    release(inputAudioBlock);
}

void MDAElecPiano::volume(float value)
{
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectFloat has built-in volume function in dB, will set m_volume for us
    m_piano->setVolume(m_volume);

    // Demonstrate the efxLogger.printf() function to print over the USB serial port
    // Note: efxLogger.printf() statements will have no effect in RELEASE builds
    efxLogger.printf("volume change: normalized value: %f  dB value: %f\n", value, volDbValue);
}


void MDAElecPiano::processMidi(int status, int data1, int data2) {
    uint8_t type = status & 0xF0U;
    uint8_t channel = status & 0x0FU;
    efxLogger.printf("MicroDexed::MDAElecPiano(): type:%02X channel:%02X  data1:%d  data2:%d\n", type, channel, data1, data2);

    uint8_t note = data1;
    uint8_t velocity = data2;
    const uint8_t midibase=1; //Midi channel OM, LM=midibase+

    if (type == 0x90U) {
        m_piano->noteOn(data1, data2);
    }

    else if (type == 0x80U) {
        m_piano->noteOff(data1);
    }
}

void MDAElecPiano::program(float value)
{
    m_program = getUserParamValue(Program_e, value);
    unsigned progSel = static_cast<unsigned>(m_program);
    if (progSel >= NPROGS) { progSel = 0; }
    m_piano->setProgram(progSel);
    efxLogger.printf("MDAElecPiano::program(): program set to %u\n", progSel);
}

void MDAElecPiano::envelopedecay(float value)
{
    m_envelopedecay = value;
    m_piano->setDecay(m_envelopedecay);
    efxLogger.printf("MDAElecPiano::envelopedecay(): decay set to %f\n", m_envelopedecay);
}

void MDAElecPiano::enveloperelease(float value)
{
    m_enveloperelease = value;
    m_piano->setRelease(m_enveloperelease);
    efxLogger.printf("MDAElecPiano::enveloperelease(): release set to %f\n", m_enveloperelease);
}

void MDAElecPiano::width(float value)
{
    m_width = value;
    m_piano->setStereo(m_width);
    efxLogger.printf("MDAElecPiano::width(): width set to %f\n", m_width);
}

void MDAElecPiano::velocitysensitivity(float value)
{
    m_velocitysensitivity = value;
    m_piano->setVelocitySense(m_velocitysensitivity);
    efxLogger.printf("MDAElecPiano::velocitysensitivity(): velocity sensitivity set to %f\n", m_velocitysensitivity);
}

void MDAElecPiano::treble(float value)
{
    m_treble = value;
    m_piano->setTreble(m_treble);
    efxLogger.printf("MDAElecPiano::treble(): treble set to %f\n", m_treble);
}

void MDAElecPiano::polyphony(float value)
{
    m_polyphony = getUserParamValue(Polyphony_e, value);
    m_piano->setPolyphony(m_polyphony);
    efxLogger.printf("MDAElecPiano::polyphony(): polyphony set to %u\n", m_polyphony);
}

void MDAElecPiano::tune(float value)
{
    m_tune = value;
    m_piano->setTune(m_tune);
    efxLogger.printf("MDAElecPiano::tune(): tune set to %f\n", m_tune);
}

void MDAElecPiano::detune(float value)
{
    m_detune = value;
    m_piano->setDetune(m_detune);
    efxLogger.printf("MDAElecPiano::detune(): detune set to %f\n", m_detune);
}

void MDAElecPiano::overdrive(float value)
{
    m_overdrive = value;
    m_piano->setOverdrive(m_overdrive);
    efxLogger.printf("MDAElecPiano::overdrive(): overdrive set to %f\n", m_overdrive);
}

void MDAElecPiano::pantremolo(float value)
{
    m_pantremolo = value;
    m_piano->setPanTremolo(m_pantremolo);
    efxLogger.printf("MDAElecPiano::pantremolo(): pan tremolo set to %f\n", m_pantremolo);
}

void MDAElecPiano::panlfo(float value)
{
    m_panlfo = value;
    m_piano->setPanLFO(m_panlfo);
    efxLogger.printf("MDAElecPiano::panlfo(): pan LFO set to %f\n", m_panlfo);
}

}
